struct LexerCursor
    position : Integer
    line : Integer
    column : Integer
endstruct

fn new_cursor (position : Integer = 0, line : Integer = 1, column : Integer = 1) returns LexerCursor
    let cursor = LexerCursor()
    cursor.position = position
    cursor.line = line
    cursor.column = column

    return cursor
endfn

fn (cursor : LexerCursor) advance_column(n : Integer = 1)
    cursor.position += n
    cursor.column += n
endfn

fn (cursor : LexerCursor) advance_line()
    cursor.line += 1
    cursor.column = 1
endfn

fn (cursor : LexerCursor) can_continue(input : String, amount : Integer = 1) returns Boolean
    return (cursor.position + amount) <= length(input)
endfn

struct LexerToken
    name : String
    value : Any
    line : Integer
    column : Integer
endstruct

fn new_token (name : String, value : Any, line : Integer = null, column : Integer = null) returns LexerToken
    let token = LexerToken()
    token.name = name
    token.value = value
    token.line = line
    token.column = column

    return token
endfn

fn (token : LexerToken) matches_token(input : String, position : Integer) returns Boolean
    if length(token.name) < length(name) then
        return false
    endif
endfn

fn lex_string(input : String, cursor : LexerCursor) returns List
    let tokens = []
    if cursor.can_continue(input) and input[cursor.position] == "\"" then
        cursor.advance_column() # Skip the "
	let spanned = span(input, "\"")
    endif
endfn
let cur = new_cursor()
print(lex_string("\"This is a test\"", cur))

fn lex(input : String) returns List
    let cursor = new_cursor()

endfn
