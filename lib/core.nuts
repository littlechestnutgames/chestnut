fn gettype(o : Any) returns String
    return __internal_type__(o)
endfn

import "result"
import "error"
fn xor(left : Any, right : Any) returns Boolean
    return (left or right) and not (left and right)
endfn

fn nand(left : Any, right : Any) returns Boolean
    return not (left and right)
endfn

fn nor(left : Any, right : Any) returns Boolean
    return not left and not right
endfn

fn xnor(left : Any, right : Any) returns Boolean
    return (left and right) or (not left and not right)
endfn

fn push(l : List, item : Any)
    insert(l, item, length(l))
endfn

fn unshift(l : List, item : Any)
    insert(l, item, 0)
endfn

fn pop(l : List) returns (Any, Error)
    if length(l) == 0
        return (null, Error("Attempt to pop an empty list"))
    endif
    return (remove(l, length(l)-1), null)
endfn

fn shift(l : List) returns (Any, Error)
    if length(l) == 0
        return (null, Error("Attempt to shift an empty list"))
    endif
    return (remove(l, 0), null)
endfn

fn reverse_string(s : String) returns String
    let i = length(s)-1
    let str = ""
    do
        str += s[i]
        i -= 1
    until i < 0
    return str
endfn

fn print(variadic a : Any)
    return __internal_print__(spread a)
endfn

fn printline(variadic a : Any)
    return __internal_printline__(spread a)
endfn

fn printline(variadic a : String)
    return __internal_printline__(spread a)
endfn

fn printline(f : Float)
    return __internal_printline__(f)
endfn

fn length(a : List) returns Integer
    return __internal_length__(a)
endfn

fn length(a : String) returns Integer
    return __internal_length__(a)
endfn

fn length(a : Any) returns Integer
    return __internal_length__(a)
endfn

fn insert(l : List, a : Any, i : Integer)
    return __internal_insert__(l, a, i)
endfn

fn readline() returns String
    return __internal_readline__()
endfn

fn remove(l : List, i : Integer) returns Any
    return __internal_remove__(l, i)
endfn

fn index_of(l : List, value : Any) returns Integer
    let found_idx = -1
    for l as item
        if item == value
            found_idx = loop_index
            break
        endif
    endfor
    return found_idx
endfn

fn range (start : Integer, end : Integer) returns List
    let r = []

    if start < end
        let i = start
        while i < end
            push(r, i)
            i += 1
        endwhile
    elif start > end
        let i = start
        while i > end
            push(r, i)
            i -= 1
        endwhile
    else
        push(r, start)
    endif
    return r
endfn

fn slice (input : String, position_start : Integer, position_end : Integer = -1) returns String
    let l = length(input)
    let end = use position_end over l unless position_end < 0 or position_end > l
    let start = use position_start over 0 unless position_start < 0
    let r = range(start, end)
    let sliced = ""
    for r as index
        sliced += input[index]
    endfor
    return sliced
endfn

fn split(input : String, delimiter : String, number : Integer = -1) returns List
    if number == 0
        return [input]
    endif

    let parts = []
    let i = 0
    let built_str = ""
    while i < length(input)
        if length(parts) < number or number < 0
            if input[i] != delimiter or
               (
                   i != 0 and
                   input[i] == delimiter and
                   input[i-1] == "\\"
               )
               built_str += input[i]
            else
                push(parts, built_str)
                built_str = ""
            endif
        else
            built_str += input[i]
        endif
        i = i + 1
    endwhile
    if built_str != ""
        push(parts, built_str)
    endif

    return parts
endfn

fn span (input : String, terminator : String) returns String
    let spanned_str = ""
    let i = 0
    while i < length(input)
        if input[i] == terminator
	   if i == 0 or (i != 0 and input[i - 1] != "\\")
	       break
	   endif
	endif
	spanned_str += input[i]
	i += 1
    endwhile
    return spanned_str
endfn

fn open_file(path : String, mode : String) returns Result
    return Result.from_tuple(__internal_open_file__(path, mode))
endfn

fn read_file_handle(handle : FileHandle, size : Integer) returns Result
    return Result.from_tuple(__internal_read_file__(handle, size))
endfn

fn write_file_handle(handle : FileHandle, data : Any) returns Result
    return Result.from_tuple(__internal_write_file__(handle, data))
endfn

fn delete_file(path: String) returns Result
    return Result.from_tuple(__internal_delete_file__(path))
endfn

fn close_file(handle : FileHandle) returns Result
    return Result.from_tuple(__internal_close_file__(handle))
endfn

fn halt(message : Any)
    __internal_halt__(message)
endfn

fn env_unset(var_name : String)
    __internal_env_unset__(var_name)
endfn

fn env_get(var_name : String, default : String = null) returns String
    return __internal_env_get__(var_name, default)
endfn

fn env_set(var_name : String, value : String)
    __internal_env_set__(var_name, value) 
endfn

fn float(a : Any) returns Float
    return __internal_to_float__(a)
endfn

fn int(a : Any) returns Integer
    return __internal_to_int__(a)
endfn

fn int8(a : Any) returns Int8
    return __internal_to_int8__(a)
endfn

fn int16(a : Any) returns Int16
    return __internal_to_int16__(a)
endfn

fn int32(a : Any) returns Int32
    return __internal_to_int32__(a)
endfn

fn int64(a : Any) returns Int64
    return __internal_to_int64__(a)
endfn

fn int128(a : Any) returns Int128
    return __internal_to_int128__(a)
endfn

fn int256(a : Any) returns Int256
    return __internal_to_int256__(a)
endfn

fn int512(a : Any) returns Int512
    return __internal_to_int512__(a)
endfn

fn int1024(a : Any) returns Integer
    return __internal_to_int1024__(a)
endfn

fn bytes(a : Any) returns List
    return __internal_to_uint8__(a)
endfn

fn from_bytes(a : Any) return String
    return __internal_from_bytes_to_string__(a)
endfn

fn uint8(a : Any) returns UInt8
    return __internal_to_uint8__(a)
endfn

fn uint16(a : Any) returns UInt16
    return __internal_to_uint16__(a)
endfn

fn uint32(a : Any) returns UInt32
    return __internal_to_uint32__(a)
endfn

fn uint64(a : Any) returns UInt64
    return __internal_to_uint64__(a)
endfn

fn uint128(a : Any) returns UInt128
    return __internal_to_uint128__(a)
endfn

fn uint256(a : Any) returns UInt256
    return __internal_to_uint256__(a)
endfn

fn uint512(a : Any) returns UInt512
    return __internal_to_uint512__(a)
endfn

fn uint1024(a : Any) returns UInt1024
    return __internal_to_uint1024__(a)
endfn

fn int_list_to_hex_string(l : List) returns String
    return __internal_int_list_to_hex__(l)
endfn

fn get_bit_width(v : Integer) returns Integer
    return __internal_get_bit_width__(v)
endfn

fn pack_bits(target_bit_width : Integer, variadic original_bytes : Any) returns UnsignedInteger
    let get_cast_fn = fn (bit_width : Integer) returns Function
        let func = null
        case bit_width
            when 8
                func = uint8
            when 16
                func = uint16
            when 32
                func = uint32
            when 64
                func = uint64
            when 128
                func = uint128
            when 256
                func = uint256
            when 512
                func = uint512
            when 1024
                func = uint1024
            otherwise
                halt("Unidentified UnsignedInteger type \"{{ b_type }}\"")
        endcase

        return func
    endfn
    let cast_fn = get_cast_fn(target_bit_width)
    let original_len = length(original_bytes)
    if original_len == 0
        return cast_fn(0)
    endif

    let bit_len = get_bit_width(original_bytes[0])

    # Guard from bits that won't fit into the target size.
    if (bit_len * original_len) > target_bit_width
        halt("Original bytes cannot fit into target bit width.")
    endif


    let prev_type = null
    let working = cast_fn(0)

    for original_bytes as byte
        # To keep things uniform and simple, all bytes must be the same length.
        if prev_type != null and gettype(byte) != prev_type
            halt("All bytes must be the same size.")
        endif

        working = working | (cast_fn(byte) << (target_bit_width - bit_len * (loop_index + 1)))

        prev_type = gettype(byte)
    endfor

    return working
endfn

fn get_time() returns Float
    return __internal_get_time__()
endfn

fn round(v : Float, d : Integer = null) returns Float
    return __internal_round__(v, d)
endfn

fn ceil(v : Number) returns Float
    return __internal_ceil__(v)
endfn

fn ceil(v : Float) returns Float
    return __internal_ceil__(v)
endfn

fn floor(v : Float) returns Float
    return __internal_floor__(v)
endfn

fn average (variadic numbers : Number)
    let sum = 0
    for numbers as num
        sum += num
    endfor

    return sum / length(numbers)
endfn

fn will_halt (func : Function, variadic params : Any) returns Boolean
    return __internal_will_halt__(func, spread params)
endfn

fn contains (l : List, v: Any) returns Boolean
    return index_of(l, v) >= 0
endfn

fn make_struct(s : StructNode) returns StructNode
    return s()
endfn

fn pad_left (s : String, char : String, min_length : Integer = 1)
    if length(s) >= min_length
        return s
    endif
    let pad_num = min_length - length(s)
    while loop_index < pad_num
        s = "{{ char }}{{ s }}"
    endwhile
    return s
endfn

fn may_halt_or_return(func : Function) returns Result
    return Result.from_tuple(__internal_may_halt_or_return__(func))
endfn

fn maybe_outer(ident : Any) returns Result
    return may_halt_or_return(fn () outer ident endfn)
endfn
