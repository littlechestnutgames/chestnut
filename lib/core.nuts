fn gettype(o : Any) returns String
    return __internal_type__(o)
endfn

struct Error
    message : String
endstruct

fn (err : Error) getError() returns String
    return err.message
endfn

fn error(message : String) returns Error
    let e = Error()
    e.message = message
    return e
endfn

fn xor(left : Any, right : Any) returns Boolean
    return (left or right) and not (left and right)
endfn

fn nand(left : Any, right : Any) returns Boolean
    return not (left and right)
endfn

fn nor(left : Any, right : Any) returns Boolean
    return not left and not right
endfn

fn xnor(left : Any, right : Any) returns Boolean
    return (left and right) or (not left and not right)
endfn

fn push(l : List, item : Any)
    insert(l, item, length(l))
endfn

fn unshift(l : List, item : Any)
    insert(l, item, 0)
endfn

fn pop(l : List) returns (Any, Error)
    if length(l) == 0 then
        return (null, error("Attempt to pop an empty list"))
    endif
    return (remove(l, length(l)-1), null)
endfn

fn shift(l : List) returns (Any, Error)
    if length(l) == 0 then
        return (null, error("Attempt to shift an empty list"))
    endif
    return (remove(l, 0), null)
endfn

fn reverse_string(s : String) returns String
    let i = length(s)-1
    let str = ""
    until i < 0 repeat
        str += s[i]
        i -= 1
    enduntil
    return str
endfn

fn print(variadic a : Any)
    __internal_print__(spread a)
endfn

fn length(a : List) returns Integer
    return __internal_length__(a)
endfn

fn length(a : String) returns Integer
    return __internal_length__(a)
endfn

fn insert(l : List, a : Any, i : Integer)
    return __internal_insert__(l, a, i)
endfn

fn readline() returns String
    return __internal_readline__()
endfn

fn remove(l : List, i : Integer) returns Any
    return __internal_remove__(l, i)
endfn

struct Result
    value : Any
    error : Error
endstruct

fn new_result(value : Any, err: Any) returns Result
    let result = Result()
    result.value = value
    result.error = err
    return result
endfn

fn new_result_from_tuple(tuple : Tuple) returns Result
    if length(tuple) < 2 then
        return new_result(null, error("new_result_from_tuple called on Tuple {{ tuple }}, but does not have two values"))
    endif
    let success, err = tuple
    return new_result(success, err)
endfn

fn (result : Result) unwrap_or (default_value : Any) returns Any
    return use result.value over default_value unless result.error != null
endfn

fn (result : Result) and_then (func : Function) returns Result
    if result.error != null then
        return result
    endif
    return func(result.value)
endfn

fn range (start : Integer, end : Integer) returns List
    let r = []
    let l = start
    while l < end repeat
       push(r, l)
       l += 1
    endwhile
    return r
endfn

fn slice (input : String, position_start : Integer, position_end : Integer = -1) returns String
    let l = length(input)
    let end = use position_end over l unless position_end < 0 or position_end > l
    let start = use position_start over 0 unless position_start < 0
    let r = range(start, end)
    let sliced = ""
    iterate r with index
        sliced += input[index]
    enditerate
    return sliced
endfn

fn span (input : String, terminator : String) returns Result
    let str = ""
    let i = 0
    let found = false
    while i < length(input) repeat
        if input[i] == terminator then
	   if i != 0 and input[i - 1] != "\\" then
	       found = true
	       break
	   endif
	endif
	str += input[i]
	i += 1
    endwhile
    let err = use null over error("Unterminated String span") unless not found
    return (str, err)
endfn

