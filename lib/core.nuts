struct TableRecord
    key : String
    value : Any
endstruct

fn new_table_record (k : String, v : Any) returns TableRecord
    let tr = TableRecord()
    tr.key = k
    tr.value = v

    return tr
endfn

struct Table
    records : List  
endstruct

fn new_table() returns Table
    let t = Table()
    t.records = []

    return t
endfn

fn (t : Table) get_index(k : String) returns Integer
    let index = -1
    iterate t.records with record
        if k == record.key then
            index = loop_index
            break
        endif
    enditerate
    return index
endfn

fn (t : Table) exists(k : String) returns Boolean
    return get_index(k) != -1
endfn

fn (t : Table) get(k : String, default : Any = null) returns Any
    iterate t.records with record
        if record.key == k then
            return record.value
        endif
    enditerate
    return default
endfn

fn (t : Table) set(k : String, v : Any)
    let index = t.get_index(k)
    if index == -1 then
        push(t.records, new_table_record(k, v))
    else
        t.records[index].value = v
    endif
endfn

fn gettype(o : Any) returns String
    return __internal_type__(o)
endfn

struct Error
    message : String
    error: Error
endstruct

fn error(message : String, err : Error = null) returns Error
    let e = Error()
    e.message = message
    e.error = err
    return e
endfn

struct Result
    value : Any
    error : Error
endstruct

fn new_result(value : Any, err: Any) returns Result
    let result = Result()
    result.value = value
    result.error = err
    return result
endfn

fn new_result_from_tuple(tuple : Any) returns Result
    if length(tuple) < 2 then
        return new_result(null, error("new_result_from_tuple called on Tuple {{ tuple }}, but does not have two values"))
    endif
    let success, err = tuple
    return new_result(success, err)
endfn

fn (result : Result) unwrap_or (default_value : Any) returns Any
    return use result.value
               over default_value
               unless result.error != null
endfn

fn (result : Result) wrap_err (message : String) returns Result
    let e = err
    if result.error != null then
    endif
    return result
endfn

fn (result : Result) and_then (func : Function) returns Result
    if result.error != null then
        return result
    endif
    return func(result.value)
endfn

fn (result : Result) catching (func : Function) returns Result
    if result.error then
        return func(result.error)
    endif
    return result
endfn

fn (result : Result) unwrap_or_fallback (func : Function) returns Any
   if result.error == null then
       return result.value
   endif
   return func(result.error)
endfn

fn xor(left : Any, right : Any) returns Boolean
    return (left or right) and not (left and right)
endfn

fn nand(left : Any, right : Any) returns Boolean
    return not (left and right)
endfn

fn nor(left : Any, right : Any) returns Boolean
    return not left and not right
endfn

fn xnor(left : Any, right : Any) returns Boolean
    return (left and right) or (not left and not right)
endfn

fn push(l : List, item : Any)
    insert(l, item, length(l))
endfn

fn unshift(l : List, item : Any)
    insert(l, item, 0)
endfn

fn pop(l : List) returns (Any, Error)
    if length(l) == 0 then
        return (null, error("Attempt to pop an empty list"))
    endif
    return (remove(l, length(l)-1), null)
endfn

fn shift(l : List) returns (Any, Error)
    if length(l) == 0 then
        return (null, error("Attempt to shift an empty list"))
    endif
    return (remove(l, 0), null)
endfn

fn reverse_string(s : String) returns String
    let i = length(s)-1
    let str = ""
    until i < 0 repeat
        str += s[i]
        i -= 1
    enduntil
    return str
endfn

fn print(variadic a : Any)
    __internal_print__(spread a)
endfn

fn print(a : Integer)
    __internal_print__(a)
endfn

fn length(a : List) returns Integer
    return __internal_length__(a)
endfn

fn length(a : String) returns Integer
    return __internal_length__(a)
endfn

fn length(a : Any) returns Integer
    return __internal_length__(a)
endfn

fn insert(l : List, a : Any, i : Integer)
    return __internal_insert__(l, a, i)
endfn

fn readline() returns String
    return __internal_readline__()
endfn

fn remove(l : List, i : Integer) returns Any
    return __internal_remove__(l, i)
endfn

fn range (start : Integer, end : Integer) returns List
    let r = []
    let l = start
    while l < end repeat
       push(r, l)
       l += 1
    endwhile
    return r
endfn

fn slice (input : String, position_start : Integer, position_end : Integer = -1) returns String
    let l = length(input)
    let end = use position_end over l unless position_end < 0 or position_end > l
    let start = use position_start over 0 unless position_start < 0
    let r = range(start, end)
    let sliced = ""
    iterate r with index
        sliced += input[index]
    enditerate
    return sliced
endfn

fn span (input : String, terminator : String) returns Result
    let str = ""
    let i = 0
    let found = false
    while i < length(input) repeat
        if input[i] == terminator then
	   if i != 0 and input[i - 1] != "\\" then
	       found = true
	       break
	   endif
	endif
	str += input[i]
	i += 1
    endwhile
    let err = use null over error("Unterminated String span") unless not found
    return (str, err)
endfn

fn open_file(path : String, mode : String) returns Result
    return new_result_from_tuple(__internal_open_file__(path, mode))
endfn

fn read_file_handle(handle : FileHandle, size : Integer) returns Result
    return new_result_from_tuple(__internal_read_file__(handle, size))
endfn

fn close_file(handle : FileHandle) returns Result
    return new_result_from_tuple(__internal_close_file__(handle))
endfn

fn halt(message : Any)
    __internal_halt__(message)
endfn
