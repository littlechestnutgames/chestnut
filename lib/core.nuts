struct TableRecord
    key : String
    value : Any
endstruct

struct Table
    records : List  
endstruct

fn (t : Table) get_index(k : String) returns Integer
    let index = -1
    iterate t.records with record
        if k == record.key then
            index = loop_index
            break
        endif
    enditerate
    return index
endfn

fn (t : Table) exists(k : String) returns Boolean
    return get_index(k) != -1
endfn

fn (t : Table) get(k : String, default : Any = null) returns Any
    iterate t.records with record
        if record.key == k then
            return record.value
        endif
    enditerate
    return default
endfn

fn (t : Table) set(k : String, v : Any)
    let index = t.get_index(k)
    if index == -1 then
        push(t.records, TableRecord(k, v))
    else
        t.records[index].value = v
    endif
endfn

fn gettype(o : Any) returns String
    return __internal_type__(o)
endfn

struct Error
    message : String
    error: Error
endstruct

fn error(message : String, err : Error = null) returns Error
    let e = Error()
    e.message = message
    e.error = err
    return e
endfn

struct Result
    value : Any
    error : Error
endstruct

fn new_result(value : Any, err: Any) returns Result
    let result = Result()
    result.value = value
    result.error = err
    return result
endfn

fn new_result_from_tuple(tuple : Any) returns Result
    if length(tuple) < 2 then
        return new_result(null, error("new_result_from_tuple called on Tuple {{ tuple }}, but does not have two values"))
    endif
    let success, err = tuple
    return new_result(success, err)
endfn

fn (result : Result) unwrap_or (default_value : Any) returns Any
    return use result.value
               over default_value
               unless result.error != null
endfn

fn (result : Result) wrap_err (message : String) returns Result
    let e = err
    if result.error != null then
    endif
    return result
endfn

fn (result : Result) and_then (func : Function, variadic params : Any) returns Result
    if result.error != null or result.value == null then
        return result
    endif
    let call_result = func(result.value, spread params)
    if gettype(call_result) == "Result" then
        return call_result
    else
        return Result(call_result, null)
    endif
endfn

fn (result: Result) catching (func : Function, variadic params : Any) returns Result
    if result.error != null then
        let call_result = func(result.error, spread params)
        if gettype(call_result) == "Result" then
            return call_result
        else
            return Result(null, call_result)
        endif
    else
        return result
    endif
endfn

fn (result : Result) unwrap_or_fallback (func : Function) returns Any
   if result.error == null then
       return result.value
   endif
   return func(result.error)
endfn

fn xor(left : Any, right : Any) returns Boolean
    return (left or right) and not (left and right)
endfn

fn nand(left : Any, right : Any) returns Boolean
    return not (left and right)
endfn

fn nor(left : Any, right : Any) returns Boolean
    return not left and not right
endfn

fn xnor(left : Any, right : Any) returns Boolean
    return (left and right) or (not left and not right)
endfn

fn push(l : List, item : Any)
    insert(l, item, length(l))
endfn

fn unshift(l : List, item : Any)
    insert(l, item, 0)
endfn

fn pop(l : List) returns (Any, Error)
    if length(l) == 0 then
        return (null, error("Attempt to pop an empty list"))
    endif
    return (remove(l, length(l)-1), null)
endfn

fn shift(l : List) returns (Any, Error)
    if length(l) == 0 then
        return (null, error("Attempt to shift an empty list"))
    endif
    return (remove(l, 0), null)
endfn

fn reverse_string(s : String) returns String
    let i = length(s)-1
    let str = ""
    until i < 0 repeat
        str += s[i]
        i -= 1
    enduntil
    return str
endfn

fn print(variadic a : Any)
    __internal_print__(spread a)
endfn

fn length(a : List) returns Integer
    return __internal_length__(a)
endfn

fn length(a : String) returns Integer
    return __internal_length__(a)
endfn

fn length(a : Any) returns Integer
    return __internal_length__(a)
endfn

fn insert(l : List, a : Any, i : Integer)
    return __internal_insert__(l, a, i)
endfn

fn readline() returns String
    return __internal_readline__()
endfn

fn remove(l : List, i : Integer) returns Any
    return __internal_remove__(l, i)
endfn

fn range (start : Integer, end : Integer) returns List
    let r = []
    let l = start
    let use_addition = true
    if start > end then
        use_addition = false
    endif
    while l < end repeat
       push(r, l)
       if use_addition then
           l += 1
       else
           l -= 1
       endif
    endwhile
    return r
endfn

fn slice (input : String, position_start : Integer, position_end : Integer = -1) returns String
    let l = length(input)
    let end = use position_end over l unless position_end < 0 or position_end > l
    let start = use position_start over 0 unless position_start < 0
    let r = range(start, end)
    let sliced = ""
    iterate r with index
        sliced += input[index]
    enditerate
    return sliced
endfn

fn split(input : String, delimiter : String, number : Integer = -1) returns List
    if number == 0 then
        return [input]
    endif

    let parts = []
    let i = 0
    let built_str = ""
    while i < length(input) repeat
        if length(parts) < number or number < 0 then
            if input[i] != delimiter or
               (
                   i != 0 and
                   input[i] == delimiter and
                   input[i-1] == "\\"
               ) then
               built_str += input[i]
            else
                push(parts, built_str)
                built_str = ""
            endif
        else
            built_str += input[i]
        endif
        i = i + 1
    endwhile
    if built_str != "" then
        push(parts, built_str)
    endif

    return parts
endfn

fn span (input : String, terminator : String) returns String
    let spanned_str = ""
    let i = 0
    while i < length(input) repeat
        if input[i] == terminator then
	   if i == 0 or (i != 0 and input[i - 1] != "\\") then
	       break
	   endif
	endif
	spanned_str += input[i]
	i += 1
    endwhile
    return spanned_str
endfn

fn open_file(path : String, mode : String) returns Result
    return new_result_from_tuple(__internal_open_file__(path, mode))
endfn

fn read_file_handle(handle : FileHandle, size : Integer) returns Result
    return new_result_from_tuple(__internal_read_file__(handle, size))
endfn

fn write_file_handle(handle : FileHandle, data : Any) returns Result
    return new_result_from_tuple(__internal_write_file__(handle, data))
endfn

fn delete_file(path: String) returns Result
    return new_result_from_tuple(__internal_delete_file__(path))
endfn

fn close_file(handle : FileHandle) returns Result
    return new_result_from_tuple(__internal_close_file__(handle))
endfn

fn halt(message : Any)
    __internal_halt__(message)
endfn

fn env_unset(var_name : String)
    __internal_env_unset__(var_name)
endfn

fn env_get(var_name : String, default : String = null) returns String
    return __internal_env_get__(var_name, default)
endfn

fn env_set(var_name : String, value : String)
    __internal_env_set__(var_name, value) 
endfn

fn bytes(a : Any) returns List
    return __internal_to_uint8__(a)
endfn

fn from_bytes(a : Any) return String
    return __internal_from_bytes_to_string__(a)
endfn

fn uint8(a : Any) returns UInt8
    return __internal_to_uint8__(a)
endfn

fn uint64(a : Any) returns UInt16
    return __internal_to_uint64__(a)
endfn
