struct HashMap
    buckets : List
    size : Integer
    initial_size : Integer
    keys : Integer
    keys_list : List
endstruct

struct KV
    key : String
    value : Any
endstruct

# Initializes a new bucket of size {initial_size}
# Note: Bucket sizes are powers of 2. For example, 
# the default of 7 means that the amount of buckets
# will be 128. HashMaps won't shrink past the initial
# size specified.
fn new_hashmap(initial_size : Integer = 7) returns HashMap
    if initial_size < 0 then
        halt("HashMap initial size cannot be less than 0.")
    endif

    let hm = HashMap()
    hm.buckets = []
    hm.size = initial_size
    hm.initial_size = initial_size
    hm.keys = 0
    hm.keys_list = []
    hm.resize(initial_size)
    return hm
endfn

# Returns a new KV struct instances with key {key} and value {value}.
fn new_kv(key : String, value : Any) returns KV
    let kv = KV()
    kv.key = key
    kv.value = value
    return kv
endfn

# Resizes the bucket (up or down) and rehases all keys in the old buckets.
fn (h : HashMap) resize(new_size : Integer)
    # Check if the resize is valid.
    if new_size < 0 then
        halt("HashMap cannot be resized to under 0.")
    endif

    # If any keys were stored, save the old buckets.
    let old_buckets = null
    if length(h.buckets) != 0 then
        old_buckets = h.buckets
    endif

    # Initialize new buckets at 2 ** new_size size.
    let buckets = []
    for range(0, 2**new_size) as bucket
        push(buckets, [])
    endfor

    # Reset metadata and set buckets.
    h.size = new_size
    h.keys = 0
    h.buckets = buckets

    # Insert the old bucket data.
    if old_buckets != null then
        for old_buckets as bucket
            for bucket as entry
                h.set(entry.key, entry.value)
            endfor
        endfor
    endif
endfn

# Calculates the bucket a given key will exist in.
fn (h : HashMap) hash(key : String) returns Integer
    # FNV_offset_basis and prime.
    let idx = uint64(14695981039346656037)
    constant FNV_prime = uint64(1099511628211)

    # Calculate the hash
    for uint64(key) as byte
        idx = uint64(idx ^ byte)
        idx = idx * FNV_prime
    endfor

    # Apply the mask.
    return idx & (uint64(2 ** h.size) - uint64(1))
endfn

# Sets a key {value} pair in the buckets at {key}
fn (h : HashMap) set(key : String, value : Any)
    if h.keys * 4 > 2 ** h.size * 3 and h.size < 63 then
        # We have exceeded load factor 0.75. Resize array up, bounded by 2**63
        h.resize(h.size + 1)
    endif

    # Setup
    let bucket_index = h.hash(key)
    let found = false

    # Find an existing key
    for h.buckets[bucket_index] as item
        if item.key == key then
            # Update the key and mark it as found so we don't insert a duplicate
            item.value = value
            found = true
            break
        endif
    endfor

    # If now found, we have to insert a new key.
    if not found then
        h.keys = h.keys + 1
        push(h.keys_list, key)
        push(h.buckets[bucket_index], new_kv(key, value))
    endif
endfn

# Removes the value of the associated {key} from the buckets and key_list.
fn (h : HashMap) unset(key : String) returns Result
    # Setup
    let bucket_index = h.hash(key)
    let idx = -1

    # Fine the key in the bucket
    for h.buckets[bucket_index] as item
        if item.key == key then
            idx = loop_index
        endif
    endfor
    
    if idx != -1 then
        # If we found the key, pop it from the bucket
        let res = remove(h.buckets[bucket_index], idx)
        h.keys = h.keys - 1

        # Remove from tracked inserted keys.
        let keys_list_idx = index_of(h.keys_list, key)
        if keys_list_idx >= 0 then
            remove(h.keys_list, keys_list_idx)
        endif

        # Check if we have to shrink the bucket (factor of 0.25)
        if h.keys * 4 < 2 ** h.size and h.size > h.initial_size then
            h.resize(h.size - 1)
        endif

        # Return the popped index.
        return Result(res, null)
    else
        # Tell them we couldn't find it.
        return Result(null, Error("Key not found"))
    endif
endfn

# Gets the value stored in the hashmap with {key}, defaulting to {default} if not found.
fn (h : HashMap) get(key : String, default : Any = null) returns Any
    # Setup
    let bucket_index = h.hash(key)
    let kv_value = null
    let found = false

    # Find the key in the bucket
    for h.buckets[bucket_index] as item
        if item.key == key then
            kv_value = item.value
            found = true
            break
        endif
    endfor
    
    # Return the KV or the default value.
    return use kv_value over default unless not found
endfn

# Returns a list of keys in the hashmap.
fn (h : HashMap) get_keys() returns List
    return h.keys_list
endfn
