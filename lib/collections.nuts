struct HashMap
    buckets : List
    size : Integer
    initial_size : Integer
    keys : Integer
    keys_list : List
endstruct

struct KV
    key : String
    value : Any
endstruct

# Initializes a new bucket of size {initial_size}
# Note: Bucket sizes are powers of 2. For example, 
# the default of 7 means that the amount of buckets
# will be 128. HashMaps won't shrink past the initial
# size specified.
fn (HashMap) new(initial_size : Integer = 7) returns HashMap
    if initial_size < 0
        halt("HashMap initial size cannot be less than 0.")
    endif

    let hm = HashMap()
    hm.buckets = []
    hm.size = initial_size
    hm.initial_size = initial_size
    hm.keys = 0
    hm.keys_list = []
    hm.resize(initial_size)
    return hm
endfn

# Returns a new KV struct instances with key {key} and value {value}.
fn (KV) new(key : String, value : Any) returns KV
    let kv = KV()
    kv.key = key
    kv.value = value
    return kv
endfn

# Resizes the bucket (up or down) and rehases all keys in the old buckets.
fn (h : HashMap) resize(new_size : Integer)
    # Check if the resize is valid.
    if new_size < 0
        halt("HashMap cannot be resized to under 0.")
    endif

    # If any keys were stored, save the old buckets.
    let old_buckets = null
    if length(h.buckets) != 0
        old_buckets = h.buckets
    endif

    # Initialize new buckets at 2 ** new_size size.
    let buckets = []
    for range(0, 2**new_size) as bucket
        push(buckets, [])
    endfor

    # Reset metadata and set buckets.
    h.size = new_size
    h.keys = 0
    h.buckets = buckets

    # Insert the old bucket data.
    if old_buckets != null
        for old_buckets as bucket
            for bucket as entry
                h.set(entry.key, entry.value)
            endfor
        endfor
    endif
endfn

# Calculates the bucket a given key will exist in.
fn (h : HashMap) hash(key : String) returns Integer
    # FNV_offset_basis and prime.
    let idx = uint64(14695981039346656037)
    constant FNV_prime = uint64(1099511628211)

    # Calculate the hash
    for uint64(key) as byte
        idx = uint64(idx ^ byte)
        idx = idx * FNV_prime
    endfor

    # Apply the mask.
    return idx & (uint64(2 ** h.size) - uint64(1))
endfn

# Sets a key {value} pair in the buckets at {key}
fn (h : HashMap) set(key : String, value : Any)
    if h.keys * 4 > 2 ** h.size * 3 and h.size < 63
        # We have exceeded load factor 0.75. Resize array up, bounded by 2**63
        h.resize(h.size + 1)
    endif

    # Setup
    let bucket_index = h.hash(key)
    let found = false

    # Find an existing key
    for h.buckets[bucket_index] as item
        if item.key == key
            # Update the key and mark it as found so we don't insert a duplicate
            item.value = value
            found = true
            break
        endif
    endfor

    # If now found, we have to insert a new key.
    if not found
        h.keys = h.keys + 1
        push(h.keys_list, key)
        push(h.buckets[bucket_index], KV.new(key, value))
    endif
endfn

# Removes the value of the associated {key} from the buckets and key_list.
fn (h : HashMap) unset(key : String) returns Result
    # Setup
    let bucket_index = h.hash(key)
    let idx = -1

    # Fine the key in the bucket
    for h.buckets[bucket_index] as item
        if item.key == key
            idx = loop_index
        endif
    endfor
    
    if idx != -1
        # If we found the key, pop it from the bucket
        let res = remove(h.buckets[bucket_index], idx)
        h.keys = h.keys - 1

        # Remove from tracked inserted keys.
        let keys_list_idx = index_of(h.keys_list, key)
        if keys_list_idx >= 0
            remove(h.keys_list, keys_list_idx)
        endif

        # Check if we have to shrink the bucket (factor of 0.25)
        if h.keys * 4 < 2 ** h.size and h.size > h.initial_size
            h.resize(h.size - 1)
        endif

        # Return the popped index.
        return Result.new(res, null)
    else
        # Tell them we couldn't find it.
        return Result.new(null, Error.new("Key not found"))
    endif
endfn

# Gets the value stored in the hashmap with {key}, defaulting to {default} if not found.
fn (h : HashMap) get(key : String, default : Any = null) returns Any
    # Setup
    let bucket_index = h.hash(key)
    let kv_value = null
    let found = false

    # Find the key in the bucket
    for h.buckets[bucket_index] as item
        if item.key == key
            kv_value = item.value
            found = true
            break
        endif
    endfor
    
    # Return the KV or the default value.
    return use kv_value over default unless not found
endfn

# Returns a list of keys in the hashmap.
fn (h : HashMap) get_keys() returns List
    return h.keys_list
endfn

struct ListNode
    next : ListNode
    prev : ListNode
    data : Any
endstruct

fn (ListNode) new(data : Any = null, prev : ListNode = null, next : ListNode = null) returns ListNode
    let ln = ListNode()
    ln.data = data
    ln.prev = prev
    ln.next = next
    return ln
endfn

struct LinkedList
    head : ListNode
    tail : ListNode
    size : Integer
endstruct

fn (ll : LinkedList) append(data : Any = null)
    if ll.tail != null and ll.head != null
        ll.tail.next = ListNode.new(data, ll.tail, ll.head)
        ll.tail = ll.tail.next
        ll.head.prev = ll.tail
    elif ll.head == null
        ll.head = ListNode.new(data)
        ll.head.prev = ll.head
        ll.head.next = ll.head
        ll.tail = ll.head
    endif
    ll.size += 1
endfn

fn (LinkedList) new(data : Any = null) returns LinkedList
    let llist = LinkedList()
    llist.size = 0
    if data != null
        llist.append(data)
    endif
    return llist
endfn
